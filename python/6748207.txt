using namespace std;
#include "bits/stdc++.h"

// add your library with double quotation #include"" here.
//#include "atcoder/all"
//using namespace atcoder;

// define your macros here.
#define MOD 1000000007
#define PI 3.14159265358979323846264338327950288419
#define IINF 1001001001
#define LINF 1001001001001001001LL

#define ll long long
#define VLL vector<ll>
#define PLL pair<ll, ll>
#define pb push_back
#define mpair make_pair
#define pm(first, second) pb(mpair((first), (second)))
#define pff first.first
#define pfs first.second
#define psf second.first
#define pss second.second

#define REP(i,n) for(ll i = 0; i < (ll)(n); i++)
#define REPS(i, n) for(ll i = 1; i <= (ll)(n); i++)
#define RREP(i, n) for(int i = ((ll)(n)-1); i >= 0; i--)
#define RREPS(i, n) for(int i = ((ll)(n)); i > 0; i--)
#define FOR(i, a, b) for(ll i = (a); i < (b); i++)
#define SZ(x) ((ll)(x).size())
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define MAX(a, b) max((ll)(a), (ll)(b))
#define MIN(a, b) min((ll)(a), (ll)(b))
#define DCEIL(a, b) (((a)+(b)-1)/(b))
#define UNIQUE(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
#define outyn(flag) cout << ((flag)? "Yes": "No") << endl
#define outYN(flag) cout << ((flag)? "YES": "NO") << endl
#define out(output) cout << (output) << endl

template<class T>bool chmax(T &a, const T &b) { return a < b && (a = b, true); }
template<class T>bool chmin(T &a, const T &b) { return a > b && (a = b, true); }
ll qp(ll a, ll b){ll ans=1;do{if(b&1)ans=1LL*ans*a;a=1LL*a*a;}while(b>>=1);return ans;}
ll qp(ll a, ll b, ll mo){ll ans=1;do{if(b&1)ans=1LL*ans*a%mo;a=1LL*a*a%mo;}while(b>>=1);return ans;}
int DX[4] = {1, 0, -1, 0};
int DY[4] = {0, 1, 0, -1};

#define int long long

int count(vector<vector<int>> P){
    int ret = 1;
    vector<vector<bool>> visited(P.size(), vector<bool>(P[0].size(), false));
    visited[0][0] = true;
    queue<pair<int, int>> q;
    q.push(mpair(0, 0));
    while(!q.empty()){
        int h = q.front().first, w = q.front().second;
        q.pop();
        REP(i, 4){
            if(h+DY[i] < 0 || h+DY[i] >= P.size() || w+DX[i] < 0 || w+DX[i] >= P[0].size()) continue;
            if(!visited[h+DY[i]][w+DX[i]] && P[h+DY[i]][w+DX[i]] == P[0][0]){
                visited[h+DY[i]][w+DX[i]] = true;
                ret++;
                q.push(mpair(h+DY[i], w+DX[i]));
            }
        }
    }
    return ret;
}

vector<vector<int>> update(vector<vector<int>> P, int c){
    vector<vector<bool>> visited(P.size(), vector<bool>(P[0].size(), false));
    visited[0][0] = true;
    int pre = P[0][0];
    P[0][0] = c;
    queue<pair<int, int>> q;
    q.push(mpair(0, 0));
    while(!q.empty()){
        //cerr << c << endl;
        int h = q.front().first, w = q.front().second;
        q.pop();
        REP(i, 4){
            if(h+DY[i] < 0 || h+DY[i] >= P.size() || w+DX[i] < 0 || w+DX[i] >= P[0].size()) continue;
            if(!visited[h+DY[i]][w+DX[i]] && P[h+DY[i]][w+DX[i]] == pre){
                P[h+DY[i]][w+DX[i]] = c;
                visited[h+DY[i]][w+DX[i]] = true;
                q.push(mpair(h+DY[i], w+DX[i]));
            }
        }
    }
    return P;
}

//n: 何回操作後のPを受け取ったか
int dfs(vector<vector<int>> P, int c, int n){
    //cerr << c << " " << n << endl;
    if(n == 4){
        return count(update(P, c));
    }

    int ret = 0;
    for(int i = 1; i <= 6; i++){
        chmax(ret, dfs(update(P, i), c, n+1));
    }
    return ret;
}

void solve(){
    // write your solution here.

    int h, w, c;
    vector<vector<int>> P;
    while(true){
        cin >> h >> w >> c;
        if(h+w+c == 0) return;

        P = vector<vector<int>>(h, vector<int>(w));
        REP(i, h) REP(j, w) cin >> P[i][j];

        out(dfs(P, c, 0));
    }
    
}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}
