using namespace std;
#include "bits/stdc++.h"

// add your library with double quotation #include"" here.
//#include "atcoder/all"
//using namespace atcoder;

// define your macros here.
#define MOD 1000000007
#define PI 3.14159265358979323846264338327950288419
#define IINF 1001001001
#define LINF 1001001001001001001LL

#define ll long long
#define VLL vector<ll>
#define PLL pair<ll, ll>
#define pb push_back
#define mpair make_pair
#define pm(first, second) pb(mpair((first), (second)))
#define pff first.first
#define pfs first.second
#define psf second.first
#define pss second.second

#define REP(i,n) for(ll i = 0; i < (ll)(n); i++)
#define REPS(i, n) for(ll i = 1; i <= (ll)(n); i++)
#define RREP(i, n) for(int i = ((ll)(n)-1); i >= 0; i--)
#define RREPS(i, n) for(int i = ((ll)(n)); i > 0; i--)
#define FOR(i, a, b) for(ll i = (a); i < (b); i++)
#define SZ(x) ((ll)(x).size())
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define MAX(a, b) max((ll)(a), (ll)(b))
#define MIN(a, b) min((ll)(a), (ll)(b))
#define DCEIL(a, b) (((a)+(b)-1)/(b))
#define UNIQUE(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
#define outyn(flag) cout << ((flag)? "Yes": "No") << endl
#define outYN(flag) cout << ((flag)? "YES": "NO") << endl
#define out(output) cout << (output) << endl

template<class T>bool chmax(T &a, const T &b) { return a < b && (a = b, true); }
template<class T>bool chmin(T &a, const T &b) { return a > b && (a = b, true); }
ll qp(ll a, ll b){ll ans=1;do{if(b&1)ans=1LL*ans*a;a=1LL*a*a;}while(b>>=1);return ans;}
ll qp(ll a, ll b, ll mo){ll ans=1;do{if(b&1)ans=1LL*ans*a%mo;a=1LL*a*a%mo;}while(b>>=1);return ans;}
int DX[4] = {1, 0, -1, 0};
int DY[4] = {0, 1, 0, -1};

#define int long long

int p, q, a, n, ans;
pair<int, int> r;
pair<int, int> pplus(pair<int, int> a, pair<int, int> b){
    int top, bottom;
    top = a.first*b.second + b.first*a.second;
    bottom = a.second*b.second;
    if(bottom == 0){
        top = 0;
        bottom = 1;
    }
    else{
        int g = gcd(top, bottom);
        top /= g;
        bottom /= g;
    }
    return mpair(top, bottom);
}
bool lte(pair<int, int> a, pair<int, int> b){
    return a.first*b.second <= a.second*b.first;
}
bool eq(pair<int, int> a, pair<int, int> b){
    return a.first*b.second == a.second*b.first;
}
pair<int, int> rsum(vector<int> &V){
    if(SZ(V) == 4 && V[0] == 0 && V[1] == 0 && V[2] == 2 && V[3] == 2){
        int hfdfg;
        hfdfg = 0;
    }
    pair<int, int> ret = mpair(0, 1);
    REP(i, SZ(V)) if(V[i] > 0) ret = pplus(ret, mpair(1, V[i]));//ret += rational<int>(1, V[i]);
    return ret;
}
void dfs(vector<int> &V, int &prod){
    //Vsize==n+1 かつ 条件満たしていればans++でreturn
    //Vsize==n+1ならreturn
    if(SZ(V) == n+1){
        auto e = rsum(V);
        if(eq(e, r)) ans++;
        return;
    }

    //次を探索
    int Vsize = SZ(V);
    for(int i = V[Vsize-1]; prod*i <= a; i++){
        if(!lte(rsum(V), r)) continue;
        prod *= max(1LL, i);
        V.pb(i);
        dfs(V, prod);
        prod /= max(1LL, i);
        V.pop_back();
    }
}
void solve(){
    // write your solution here.

    while(true){
        cin >> p >> q >> a >> n;
        if(p == 0 && q == 0 && a == 0 && n == 0) return;
        int g = gcd(p, q);
        r = mpair(p/g, q/g);

        ans = 0;
        vector<int> V(1, 0);
        int prod = 1;
        dfs(V, prod);
        out(ans);
    }
    
}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}
