using namespace std;
#include "bits/stdc++.h"

// add your library with double quotation #include"" here.
//#include "atcoder/all"
//using namespace atcoder;

// define your macros here.
#define MOD 1000000007
#define PI 3.14159265358979323846264338327950288419
#define IINF 1001001001
#define LINF 1001001001001001001LL

#define ll long long
#define VLL vector<ll>
#define PLL pair<ll, ll>
#define pb push_back
#define mpair make_pair
#define pm(first, second) pb(mpair((first), (second)))
#define pff first.first
#define pfs first.second
#define psf second.first
#define pss second.second

#define REP(i,n) for(ll i = 0; i < (ll)(n); i++)
#define REPS(i, n) for(ll i = 1; i <= (ll)(n); i++)
#define RREP(i, n) for(int i = ((ll)(n)-1); i >= 0; i--)
#define RREPS(i, n) for(int i = ((ll)(n)); i > 0; i--)
#define FOR(i, a, b) for(ll i = (a); i < (b); i++)
#define SZ(x) ((ll)(x).size())
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define MAX(a, b) max((ll)(a), (ll)(b))
#define MIN(a, b) min((ll)(a), (ll)(b))
#define DCEIL(a, b) (((a)+(b)-1)/(b))
#define UNIQUE(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
#define outyn(flag) cout << ((flag)? "Yes": "No") << endl
#define outYN(flag) cout << ((flag)? "YES": "NO") << endl
#define out(output) cout << (output) << endl

template<class T>bool chmax(T &a, const T &b) { return a < b && (a = b, true); }
template<class T>bool chmin(T &a, const T &b) { return a > b && (a = b, true); }
ll qp(ll a, ll b){ll ans=1;do{if(b&1)ans=1LL*ans*a;a=1LL*a*a;}while(b>>=1);return ans;}
ll qp(ll a, ll b, ll mo){ll ans=1;do{if(b&1)ans=1LL*ans*a%mo;a=1LL*a*a%mo;}while(b>>=1);return ans;}
int DX[4] = {1, 0, -1, 0};
int DY[4] = {0, 1, 0, -1};

#define int long long

void nextstate(int h, int w, int command, int nowi, int nowj, int nowd, int &nexti, int &nextj, int &nextd){
    switch(command){
    case 0: //straight
        nextd = nowd;
        break;
    case 1: //right
        nextd = (nowd+1)%4;
        break;
    case 2: //back
        nextd = (nowd+2)%4;
        break;
    case 3: //left
        nextd = (nowd+3)%4;
        break;
    case 4: //halt
        nexti = -1;
        nextj = -1;
        nextd = -1;
        return;
        break;
    }
    nexti = nowi + DY[nextd];
    nextj = nowj + DX[nextd];

    if(nexti < 0 || nexti >= h || nextj < 0 || nextj >= w){
        nexti = -1;
        nextj = -1;
        nextd = -1;
    }
}
void solve(){
    // write your solution here.

    while(true){
        int w, h;
        cin >> w >> h;
        if(w*h == 0) return;

        vector<vector<int>> command(h, vector<int>(w));
        REP(i, h) REP(j, w){
            cin >> command[i][j];
        }
        vector<int> cost(4);
        REP(i, 4) cin >> cost[i];

        vector<vector<int>> dist(h, vector<int>(w, LINF));
        vector<vector<vector<bool>>> conf(h, vector<vector<bool>>(w, vector<bool>(4)));
        dist[0][0] = 0;
        pair<pair<int, int>, int> nowijd, nextijd;
        nowijd.pff = 0;
        nowijd.pfs = 0;
        nowijd.second = 0;
        int nowd, nextd;
        priority_queue<pair<int, pair<pair<int, int>, int>>, vector<pair<int, pair<pair<int, int>, int>>>, greater<pair<int, pair<pair<int, int>, int>>>> pq;
        pq.push(mpair(0, mpair(mpair(0, 0), 0)));
        while(!pq.empty()){
            nowijd.pff = pq.top().second.pff;
            nowijd.pfs = pq.top().second.pfs;
            nowijd.second = pq.top().second.second;
            nowd = pq.top().first;
            pq.pop();
            if(conf[nowijd.pff][nowijd.pfs][nowijd.second]) continue;
            if(nowijd.pff == h-1 && nowijd.pfs == w-1){
                out(nowd);
                break;
            }
            conf[nowijd.pff][nowijd.pfs][nowijd.second] = true;
            REP(c, 4){
                nextstate(h, w, c, nowijd.pff, nowijd.pfs, nowijd.second, nextijd.pff, nextijd.pfs, nextijd.second);
                if(nextijd.pff + nextijd.pfs + nextijd.second < 0) continue;
                if(conf[nextijd.pff][nextijd.pfs][nextijd.second]) continue;
                if(c == command[nowijd.pff][nowijd.pfs]) nextd = nowd;
                else nextd = nowd + cost[c];
                pq.push(mpair(nextd, mpair(mpair(nextijd.pff, nextijd.pfs), nextijd.second)));
            }
        }
    }
    
}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}
