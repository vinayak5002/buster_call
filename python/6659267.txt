/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Gosu_Hiroo
 */

#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using ld = long double;
template<typename T>
using P = array<T, 2>;
template<typename U>
using T = array<U, 3>;
template<typename T>
using V = vector<T>;
//#pragma GCC optimize("O3")
//#pragma GCC target("avx2")
//#pragma GCC target("avx512f")
//#pragma GCC optimize("unroll-loops")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
//#pragma GCC optimize("Ofast")

#define SZ(x) ((long long)(x).size())
#define READ ({long long t;cin >> t;t;})
#define overload4(_1, _2, _3, _4, name, ...) name
#define REP1(n) for(ll i=0;i<n;++i)
#define REP2(i, n) for(ll i=0;i<n;++i)
#define REP3(i, a, b) for(ll i=a;i<b;++i)
#define REP4(i, a, b, c) for(ll i=a;i<b;i+=c)
#define REP(...) overload4(__VA_ARGS__,REP4,REP3,REP2,REP1)(__VA_ARGS__)
#define RREP1(n) for(ll i=n;i--;)
#define RREP2(i, n) for(ll i=n;i--;)
#define RREP3(i, a, b) for(ll i=b;i-->(a);)
#define RREP4(i, a, b, c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)
#define RREP(...) overload4(__VA_ARGS__,RREP4,RREP3,RREP2,RREP1)(__VA_ARGS__)
#define ALL(x) (x).begin(),(x).end()
#define RALL(x) (x).rbegin(),(x).rend()
#define UNIQUE(v) sort(v.begin(), v.end()), v.erase( unique(v.begin(), v.end()), v.end())
#define EB emplace_back
#define PB push_back
#define fcout cout << fixed << setprecision(12)
#define fcerr cerr << fixed << setprecision(12)
//#define print(...) out(cout, __VA_ARGS__)
#define print(x) cout << (x) << '\n'
#define fprint(x) cout << fixed << setprecision(12) << (x) << '\n'
# define BYE(a) do { cout << (a) << endl; return ; } while (false)
#define LB lower_bound
#define UB upper_bound
#define LBI(c, x) distance((c).begin(), lower_bound((c).begin(), (c).end(), (x)))
#define UBI(c, x) distance((c).begin(), upper_bound((c).begin(), (c).end(), (x)))
#define ifn(x) if(!(x))
#define itn int
#define pritn print
#define pirnt print
#define RPE REP
#ifdef DEBUG
#define DBG(args...) ({ string _s = #args; stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); })
#define ERR(args...) ({ string _s = #args; stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(std::cerr,_it, args); })
#else
#define DBG(args...) ({})
#define ERR(args...) ({})
#endif

//@formatter:off
void _err(std::ostream& cerr, istream_iterator<string> it){cerr << endl;}
template<typename T, typename... Args>void _err(std::ostream& cerr, istream_iterator<string> it, T a, Args... args){cerr << (it->empty()||it->back()!=','?(*it):it->substr(0, it->size()-1)) << " = " << a << "  ";_err(cerr, ++it, args...);}
template<class T>int out(ostream& os, const T& t){os << t << '\n';return 0;}
template<class Head, class... Tail>int out(ostream& os, const Head& head, const Tail& ... tail){os << head << ' ';out(os, tail...);return 0;}
template<class T>auto min(T& v){return *min_element(v.begin(), v.end());}
template<class T>auto max(T& v){return *max_element(v.begin(), v.end());}
template<class U = long long, class T> auto sum(T& v){ return accumulate(v.begin(), v.end(), (U) 0); }
template<typename T, typename U> istream& operator>>(istream& is, pair<T, U>& V){ is >> V.F >> V.S; return is; }
template<typename T> istream& operator>>(istream& is, vector<T>& V){ for(auto&& ele : V)is >> ele; return is; }
template<typename T, size_t N> istream& operator>>(istream& is, array<T, N>& V){ for(auto&& ele : V)is >> ele; return is; }
template<typename T> ostream& operator<<(ostream& os, const vector<T> V){ os << "["; int cnt = 0; T curr; if(!V.empty()){ for(int i = 0; i < V.size() - 1; ++i){ if(V[i] == curr)cnt++; else cnt = 0; if(cnt == 4)os << "... "; if(cnt < 4) os << i << ":" << V[i] << " "; curr = V[i]; } os << V.size() - 1 << ":" << V.back(); } os << "]\n"; return os; }
template<typename T,size_t N> ostream& operator<<(ostream& os, const array<T,N> V){ os << "["; int cnt = 0; T curr; if(!V.empty()){ for(int i = 0; i < V.size() - 1; ++i){ if(V[i] == curr)cnt++; else cnt = 0; if(cnt == 4)os << "... "; if(cnt < 4) os << i << ":" << V[i] << " "; curr = V[i]; } os << V.size() - 1 << ":" << V.back(); } os << "]\n"; return os; }
template<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U> P){ os << "("; os << P.first << "," << P.second; os << ")"; return os; }
template<typename T, typename U> ostream& operator<<(ostream& os, const set<T, U> V){ os << "{"; if(!V.empty()){ auto it = V.begin(); for(int i = 0; i < V.size() - 1; ++i){ os << *it << " "; it++; } os << *it; } os << "}\n"; return os; }
template<typename K, typename H, typename P> ostream& operator<<(ostream& os, const unordered_set<K, H, P> V){ os << "{"; if(!V.empty()){ auto it = V.begin(); for(int i = 0; i < V.size() - 1; ++i){ os << *it << " "; it++; } os << *it; } os << "}\n"; return os; }
template<typename K, typename C> ostream& operator<<(ostream& os, const multiset<K, C> V){ os << "{"; if(!V.empty()){ auto it = V.begin(); for(int i = 0; i < V.size() - 1; ++i){ os << *it << " "; it++; } os << *it; } os << "}"; return os; }
template<typename K, typename T, typename C> ostream& operator<<(ostream& os, const map<K, T, C> V){ os << "{"; if(!V.empty()){ auto it = V.begin(); for(int i = 0; i < V.size() - 1; ++i){ os << "("; os << it->first << "," << it->second; os << ") "; it++; } os << "("; os << it->first << "," << it->second; os << ")"; } os << "}\n"; return os; }
template<typename K, typename T, typename C> ostream& operator<<(ostream& os, const unordered_map<K, T, C> V){ os << "{"; if(!V.empty()){ auto it = V.begin(); for(int i = 0; i < V.size() - 1; ++i){ os << "("; os << it->first << "," << it->second; os << ") "; it++; } os << "("; os << it->first << "," << it->second; os << ")"; } os << "}\n"; return os; }
template<typename T> ostream& operator<<(ostream& os, const deque<T> V){ os << "["; if(!V.empty()){ for(int i = 0; i < V.size() - 1; ++i){ os << V[i] << "->"; } if(!V.empty())os << V.back(); } os << "]\n"; return os; };
template<typename T, typename Cont, typename Comp> ostream& operator<<(ostream& os, const priority_queue<T, Cont, Comp> V){ priority_queue<T, Cont, Comp> _V = V; os << "["; if(!_V.empty()){ while(_V.size() > 1){ os << _V.top() << "->"; _V.pop(); } os << _V.top(); } os << "]\n"; return os; };
template<class F> struct y_combinator{ F f; template<class... Args> decltype(auto) operator()(Args&& ... args) const{ return f(*this, std::forward<Args>(args)...); } };
template<class F> y_combinator<decay_t<F>> recursive(F&& f){ return {forward<F>(f)}; }
struct hash_pair{ template<class T1, class T2> size_t operator()(const pair<T1, T2>& p) const{ auto hash1 = hash<T1>{}(p.first); auto hash2 = hash<T2>{}(p.second); return hash1^hash2; } };
template<typename U> vector<U> vec(int n, U v){ return vector<U>(n, v); }
template<typename... Args> auto vec(int n, Args... args){ auto val = vec(forward<Args>(args)...); return vector<decltype(val)>(n, move(val)); }
template<typename T, typename U = less<int>>vector<int> order(vector<T> &a, U comp = less<T>{}){V<int> res(a.size());iota(res.begin(), res.end(), 0);sort(res.begin(), res.end(), [&a,&comp](int l, int r){return comp(a[l], a[r]);});return res;}
const double PI = 2*acos(.0);
const int INF = 0x3f3f3f3f;
template<class T> inline T ceil(T a, T b){return a > 0 ? (a + b - 1)/b : a/b;}
template<class T> inline T floor(T a, T b){return a > 0 ? a/b : (a - b + 1)/b;}
inline long long popcount(ll x){return __builtin_popcountll(x);}
ll pow2(ll a){return 1ll << a;}
ll is_pow2(ll a){return a && !(a&(a-1));}
ll msb(ll a){return a ? 63 - __builtin_clzll(a) : -INF;}
ll lsb(ll a){return a ? INF: __builtin_ctzll(a);}
ll powi(ll a, ll b){ ll res = 1; while(b){ if(b&1) res *= a; a *= a; b >>= 1; } return res; }
ll powp(ll a, ll b, ll p){ ll res = 1; while(b){ if(b&1) (res *= a) %= p; (a *= a) %= p; b >>= 1; } return res; }
template<class T, class U> inline bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }
template<class T, class U> inline bool chmin(T& a, const U& b){ if(b < a){ a = b; return 1; } return 0; }
template<class U>ll bsmax(ll lo, ll hi, U f){hi++;assert(lo <= hi);while(hi > lo + 1){ll x = (hi + lo)>>1;(f(x) ? lo : hi) = x;}return lo;}
template<class U>ll bsmin(ll lo, ll hi, U f){lo--;assert(lo <= hi);while(hi > lo + 1){ll x = (hi + lo)>>1;(f(x) ? hi : lo) = x;}return hi;}
vector<int> iota(int N){ vector<int> a(N); iota(a.begin(), a.end(), 0); return a; }
vector<pair<ll, ll>> PF(ll N){ assert(N >= 1); vector<pair<ll, ll>> res; if(~N&1){ res.emplace_back(2, 1); while(~(N /= 2)&1)res.back().second++; } for(ll i = 3; i*i <= N; i += 2) if(N%i == 0){ res.push_back({i, 1}); while((N /= i)%i == 0) res.back().second++; } if(N != 1)res.push_back({N, 1}); return res; }
vector<ll> factors(ll N){ vector<ll> res; ll i = 1; for(; i*i < N; i++){ if(N%i == 0)res.emplace_back(i), res.emplace_back(N/i);} if(i*i == N)res.emplace_back(i); return res; }
//@formatter:on

struct edge{
    int s, t, w;

    bool operator<(const edge R) const{
        return w < R.w;
    }
};

#ifndef ATCODER_DSU_HPP
#define ATCODER_DSU_HPP 1

#include <algorithm>
#include <cassert>
#include <vector>

namespace atcoder {

// Implement (union by size) + (path compression)
// Reference:
// Zvi Galil and Giuseppe F. Italiano,
// Data structures and algorithms for disjoint set union problems
struct dsu {
  public:
    dsu() : _n(0) {}
    dsu(int n) : _n(n), parent_or_size(n, -1) {}

    int merge(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        int x = leader(a), y = leader(b);
        if (x == y) return x;
        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
        parent_or_size[x] += parent_or_size[y];
        parent_or_size[y] = x;
        return x;
    }

    bool same(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        return leader(a) == leader(b);
    }

    int leader(int a) {
        assert(0 <= a && a < _n);
        if (parent_or_size[a] < 0) return a;
        return parent_or_size[a] = leader(parent_or_size[a]);
    }

    int size(int a) {
        assert(0 <= a && a < _n);
        return -parent_or_size[leader(a)];
    }

    std::vector<std::vector<int>> groups() {
        std::vector<int> leader_buf(_n), group_size(_n);
        for (int i = 0; i < _n; i++) {
            leader_buf[i] = leader(i);
            group_size[leader_buf[i]]++;
        }
        std::vector<std::vector<int>> result(_n);
        for (int i = 0; i < _n; i++) {
            result[i].reserve(group_size[i]);
        }
        for (int i = 0; i < _n; i++) {
            result[leader_buf[i]].push_back(i);
        }
        result.erase(
            std::remove_if(result.begin(), result.end(),
                           [&](const std::vector<int>& v) { return v.empty(); }),
            result.end());
        return result;
    }

  private:
    int _n;
    // root node: -1 * component size
    // otherwise: parent
    std::vector<int> parent_or_size;
};

}  // namespace atcoder

#endif  // ATCODER_DSU_HPP


using namespace atcoder;

void solve(std::istream& cin, std::ostream& cout, std::ostream& cerr){
    int N;
    int ans = 0;
    cin >> N;
    auto a = vec(N, N, 0);
    cin >> a;
    dsu uf(N);
    vector<edge> edges;
    for(int i = 0; i < N - 1; ++i){
        for(int j = i + 1; j < N; ++j){
            if(a[i][j] != -1)edges.push_back({i, j, a[i][j]});
        }
    }
    sort(edges.begin(), edges.end());
    for(auto [s, t, w]: edges){
        if(uf.same(s, t))continue;
        ans += w;
        uf.merge(s, t);
    }
    cout << ans << '\n';
}


#pragma clang diagnostic pop


#undef int
int main() {
	istream& in(cin);
    ostream& out(cout);
    ostringstream err;
	in.tie(0); ios::sync_with_stdio(0);
    solve(in, out, err);
	return 0;
}

