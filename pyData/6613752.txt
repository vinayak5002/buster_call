'''
コストはサイクル毎のグループに計算できる。

各サイクルのコストは、
・そのサイクルグループの最小値を除いた各要素の重さと、
・運び屋である最小値のコストの和である。
最小値のコストは、運び屋として
・そのサイクルグループの最小値w_sorted[grp_min]を使った場合のコストと、
・全体での最小値w_sorted[0]をサイクルの外から借りてきて使って返した場合のコストのうち、
小さい方を取る。
grp_chg_cntは各サイクルの長さ-1を表していて、
長さ1のサイクルではgrp_chg_cntがゼロなのでコストはゼロになる
（最初から正しい位置にある値は長さ1のサイクル）
ソートしたリストは返却しない、コスト計算結果だけを返却する
'''


n = int(input())
w = [*map(int, input().split())]

# ソートして新たなリストを作る
w_sorted = sorted(w) 

cost = 0

# n まで 0 から 1 ずつ ソート済リスト(w_sorted)の値 を見ていく
for grp_min in range(n):
    # ①ソート済リストの一番小さい値（最小値）は、未ソートリストでは何番目か
    i = w.index(w_sorted[grp_min])
    grp_chg_cnt = 0
    
    # i(未ソートリストでは何番目か)が外側のソート済リストのインデックスより大きい間、くり返す
    # 言い換えれば未ソートリストのi番目にある文字が正しい位置に収まるまでくり返す
    while i > grp_min:

        # 入れ替え回数カウント
        grp_chg_cnt += 1 

        # 最小値ではない値（未ソートリストにある最小値の位置にある値）のインデックスを取得する
        # ①の番目にあるソート済みリストの値は未ソートリストでは何番目か
        # 対象の数字を置き換えるとき置き換える相手はソートしたらそこにあるべき値にする
        # 動いた後の後釜を正しい位置に入れるようにする
        i_pre = w.index(w_sorted[i]) 

        # 動いた後の後釜の値をコスト（最小値以外のコスト）として加算する
        # そのサイクルの最小値を除いた各要素の重さを加算
        cost += w[i_pre]

        # 未ソートリストの値を交換        
        w[i], w[i_pre] = w[i_pre], w[i]
        
        i = i_pre
    
    # 最小値のコストを算出する
    # 次の①②の小さい方
    # ①サイクルグループの最小値 * 入れ替え回数
    # ②(最小値以外の総和) + (全体の最小値 * 入れ替え回数) + (サイクルグループの最小値 * 2) + (全体の最小値 * 2)

    # cost += min(w_sorted[grp_min] * grp_chg_cnt, w_sorted[grp_min] * 2 + w_sorted[0] * (grp_chg_cnt + 2))
    cost += min(w_sorted[grp_min] * grp_chg_cnt, 
               (w_sorted[0] * grp_chg_cnt) + w_sorted[grp_min] * 2 + (w_sorted[0] * 2))
    
print(cost)
