ã²ã‚
#9917

ã¸ã‚Šã‚“ â€” 2022/06/07
èª²é¡Œã‚„ã‚‹ä¼šã‚„ã‚ŠãŸã„
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/07
ã‚ªãƒ³ãƒ©ã‚¤ãƒ³èª²é¡Œå›?
ãã‚Œãªã‚‰å®Ÿé¨“Aã‚„ã‚ŠãŸã„ã‹ãªã
ã¸ã‚Šã‚“ â€” 2022/06/07
ã¯ã„
ã‚Œã™ã¨ï¼ˆæ¾æœ¬ï¼‰ â€” 2022/06/07
ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§ä½•ã‹ã‚„ã‚‹ã®ã§ã‚ã‚Œã°ã€æŒ¨æ‹¶ãŒã¦ã‚‰å°‘ã—å‚åŠ ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹?
ã¸ã‚Šã‚“ â€” 2022/06/07
ã˜ã‚ƒã‚æˆæ¥­çµ‚ã‚ã£ã¦å°‘ã—ä¼‘æ†©æŒŸã‚“ã 15:20ã‚ãŸã‚Šã«é–‹å§‹äºˆå®šã«ã—ã‚ˆã‹
ã¸ã‚Šã‚“ â€” 2022/06/07
ğŸ¤”
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/07
ä¼šè­°ã¯çµ‚ã‚ã£ãŸã®ã§ãƒã‚¤ãƒˆã—ãªãŒã‚‰èãå°‚ã§å…¥ã‚Šã¾ã™ğŸ¤ª
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
ã¨ã‚Šã‚ãˆãšé©å½“ã«ã„ã¾ã™
ç”»åƒ
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
ã“ã®æ•™å®¤ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§ãƒ–ãƒ¬ãƒã‚¹å—ã‘ã¦ã‚‹äººãŠã‚‹ãªâ€¦ãŠã‚‚ã‚ã„ã‘ã©
ã¸ã‚Šã‚“ â€” 2022/06/14
16æ™‚éãã«ç€ãã¾ã™...
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
ã„ã¤ã‚‚ã®
ã¸ã‚Šã‚“ â€” 2022/06/14
é›¨é™ã£ã¦ã‚‹ã¨ã‹çŸ¥ã‚Šã¾ã›ã‚“
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
ã‹ãªã—ã„ã­
ã¸ã‚Šã‚“ â€” 2022/06/14
ã‚‚ã†ã¿ã‚“ãªã„ã¾ã™ã‹?
ãŒã‚“ã ã‚‹ â€” 2022/06/14
2äººã ã‘ã§ã™
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/14
è‰
ã¸ã‚Šã‚“ â€” 2022/06/14
ã¾ãå…ƒã€…ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã§è¡Œãã£ã¦è¨€ã£ã¦ãŸã®ãŒ4äººã§ã€ã‚Œã™ã¨å›ã¯æˆæ¥­ä¸­ã ã—ä»•æ–¹ãŒãªã„
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
1äººä»¥å¤–ã¯ä»•æ–¹ãŒãªã„
ã¸ã‚Šã‚“ â€” 2022/06/14
ğŸ¤”
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/14
ä»•æ–¹ãªã„ã‚ˆã­ä»Šæ—¥ã®æ•°Bé›£ã—ã‹ã£ãŸã—
ã¸ã‚Šã‚“ â€” 2022/06/14
ãã†ã ã‚ˆã­ã€ä»•æ–¹ãªã„ã‚ˆã­
æ•°Bå‡ºã¦ãªã„ã‘ã©
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/14
ã‹ã™ã˜ã‚ƒã‚“ 
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
de
ã§ãƒ˜ãƒªãƒ³ãã‚“ã¯æ¥ã‚‹ã‚“ã§ã™ã‹ï¼Ÿ
ã‚Œã™ã¨ï¼ˆæ¾æœ¬ï¼‰ â€” 2022/06/14
æˆæ¥­çµ‚ã‚ã£ãŸã‚“ã§å‚æˆ¦ã—ã¾ã™
ã¸ã‚Šã‚“ â€” 2022/06/14
äººå¢—ãˆãŸã®ã§ç§»å‹•ã—ã¾ã™
302ã«ç§»å‹•ã—ã¾ã—ãŸ@ã‚Œã™ã¨ï¼ˆæ¾æœ¬ï¼‰
ç”»åƒ
ã³ã—ã‚‡æ¿¡ã‚Œã«ãªã£ã¦ã‚‹äººé–“ãŒåƒ•ã§ã™
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” 2022/06/14
åƒ•ã¯ã„ã¾ã›ã‚“
https://kenkoooo.com/atcoder/#/contest/show/9deb0494-4ac3-4124-8355-40ee7c66f3e7
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/14
ã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ»é€”ä¸­å‚æˆ¦ã‚’ã‚­ãƒ¡ãŸ
ã˜ã‚ƒã“ã¦ã‚“ â€” 2022/06/15
ICPCã®é€£çµ¡Slackã®æ–¹èª°ã‚‚è¦‹ãªã„ãƒ»ãƒ»ãƒ»
åƒ•ã‚‚Discordè¦‹ã¦ãªã„ã®ã§äººã®ã“ã¨è¨€ãˆã¾ã›ã‚“
ã‚¯ã‚½é‹ã‚²ãƒãƒ³ â€” 2022/06/16
taskå¤šã„ã®ã§ç™»éŒ²å¾Œå›ã—ã«ã—ã¾ã™â€¦
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 13:20
ã„ã¤ã‚‚ã©ãŠã‚Šã®C302ã«ããŸ
ã²ã‚ â€” ä»Šæ—¥ 13:29
14æ™‚åŠãã‚‰ã„ã«ã¤ããã†
ã¸ã‚Šã‚“ â€” ä»Šæ—¥ 13:41
ãã‚ãã‚3ãƒãƒ¼ãƒ ã§ICPCãƒãƒãƒ£ã‚„ã‚ŠãŸã„ã­
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 13:42
:sore:
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 14:54
@ã¸ã‚Šã‚“ ãªã‚“ã˜ã«ãã¾ã™ã‹
ã­ã¦ãã†ã€OK
ä»Šæ—¥ã¯ICPCã§ã™ã‹ï¼Ÿ
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 15:07
https://onlinejudge.u-aizu.ac.jp/beta/room.html#JK_ICPC0621
ã¨ã‚Šã‚ãˆãš4é™ã®æ™‚é–“ä¸­90åˆ†é–“
AOJ-ICPCã®200,250,300
ã¸ã‚Šã‚“ â€” ä»Šæ—¥ 16:35
ã‚µãƒ³ãƒ—ãƒ«æœ¬å½“ã«ã‚ã£ã¦ã¾ã™ã‹..?
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 16:35
ã‚ã£ã¦ã¾ã™ï¼ˆã‚ã£ã¦ã¾ã™ï¼‰
çµå±€ä¼šå ´ã«ã¯æ¥ã‚‹ã‚“ã§ã™ã‹ï¼Ÿ
ã¸ã‚Šã‚“ â€” ä»Šæ—¥ 16:37
ã„ã‘ã¾ã›ã‚“ã­ ...
ã‹ã‚ãƒ¼ã“ã„ã‚“ã¨ï¼ˆæœ¬åä¸è©³ï¼‰ â€” ä»Šæ—¥ 16:38
:sonomasaka:
ãŒã‚“ã ã‚‹ â€” ä»Šæ—¥ 16:38
cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <math.h>
#include <iomanip>
#include <fstream>
#include <map>
#include <set>
#include <queue>
#include <list>
#include <iomanip>
#include <numeric>
#include <bitset>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

template<typename T1, typename T2>
class myPair : public std::pair<T1, T2>{
    using std::pair<T1, T2>::pair;
    public:
    inline const myPair<T1, T2> operator+(const myPair<T1, T2> &p) { return {this->first + p.first, this->second + p.second}; }
    inline const myPair<T1, T2> operator-(const myPair<T1, T2> &p) { return {this->first - p.first, this->second - p.second}; }
    template<typename U> inline const  myPair<T1, T2> operator*(const U &p) { return {this->first * p, this->second * p}; }
    template<typename U> inline const  myPair<T1, T2> operator/(const U &p) { return {this->first / p, this->second / p}; }
    inline myPair& operator+=(const myPair<T1, T2> &p) {
        *this = *this + p;
        return *this;
    }
    inline myPair& operator-=(const myPair<T1, T2> &p) {
        *this = *this - p;
        return *this;
    }
    template<typename U> inline myPair& operator*=(const U &x) {
        *this = *this * x;
        return *this;
    }
    template<typename U> inline myPair& operator/=(const U &x) {
        *this = *this / x;
        return *this;
    }
};
#define pair myPair


using ll = long long;
using mint = modint1000000007;
using mint_ = modint998244353;
using P = pair<int,int>;
using PL = pair<ll,ll>;
using V = vector<int>;
using VL = vector<ll>;
using VD = vector<double>;
using VC = vector<char>;
using VP = vector<P>;
using VS = vector<string>;
using VM = vector<mint>;
using VM_ = vector<mint_>;
using VV = vector<V>;
using VVL = vector<VL>;
using VVD = vector<VD>;
using VVC = vector<VC>;
using VVP = vector<VP>;
using VVS = vector<VS>;
using VVM = vector<VM>;
using VVM_ = vector<VM_>;
const int INF  = 1001001001;
const ll INFL = 1001001001001001001;
const ll MOD = 1000000007;
const ll MOD_ = 998244353;
const V DH = {-1,-1,0,1,1,1,0,-1};
const V DW = {0,1,1,1,0,-1,-1,-1};
struct grid{
    int h, w;
    inline const grid operator+(const grid &p) { return {this->h + p.h, this->w + p.w}; }
    inline const grid operator*(const int &p) { return {this->h * p, this->w * p}; }
    
};
ostream &operator<<(ostream &os, const grid& p) {
    os << p.h << " " << p.w;
    return os;
}
#define rep(i, j, n) for(ll i = (ll)(j); i < (ll)(n); i++)
#define repb(i, j, n) for(ll i = (ll)(n-1); i >= (ll)(j); i--)
#define reps(i, j, n) for(ll i = (ll)(j); i <= (ll)(n); i++)
#define repsb(i, j, n) for(ll i = (ll)(n); i >= (ll)(j); i--)
#define all(a) (a).begin(),(a).end()

template<typename T>
ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i=0; i<(int)v.size(); i++){
        os << v[i] << (i+1 != (int)v.size() ? " " : "");
    }
    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &v){
    for(T &in : v) is >> in;
... ï¼ˆæ®‹ã‚Š 192 è¡Œï¼‰
æŠ˜ã‚ŠãŸãŸã¿
message.txt
8 KB
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <math.h>
#include <iomanip>
#include <fstream>
#include <map>
#include <set>
#include <queue>
#include <list>
#include <iomanip>
#include <numeric>
#include <bitset>
using namespace std;

template<typename T1, typename T2>
class myPair : public std::pair<T1, T2>{
    using std::pair<T1, T2>::pair;
    public:
    inline const myPair<T1, T2> operator+(const myPair<T1, T2> &p) { return {this->first + p.first, this->second + p.second}; }
    inline const myPair<T1, T2> operator-(const myPair<T1, T2> &p) { return {this->first - p.first, this->second - p.second}; }
    template<typename U> inline const  myPair<T1, T2> operator*(const U &p) { return {this->first * p, this->second * p}; }
    template<typename U> inline const  myPair<T1, T2> operator/(const U &p) { return {this->first / p, this->second / p}; }
    inline myPair& operator+=(const myPair<T1, T2> &p) {
        *this = *this + p;
        return *this;
    }
    inline myPair& operator-=(const myPair<T1, T2> &p) {
        *this = *this - p;
        return *this;
    }
    template<typename U> inline myPair& operator*=(const U &x) {
        *this = *this * x;
        return *this;
    }
    template<typename U> inline myPair& operator/=(const U &x) {
        *this = *this / x;
        return *this;
    }
};
#define pair myPair


using ll = long long;
using P = pair<int,int>;
using PL = pair<ll,ll>;
using V = vector<int>;
using VL = vector<ll>;
using VD = vector<double>;
using VC = vector<char>;
using VP = vector<P>;
using VS = vector<string>;
using VV = vector<V>;
using VVL = vector<VL>;
using VVD = vector<VD>;
using VVC = vector<VC>;
using VVP = vector<VP>;
using VVS = vector<VS>;
const int INF  = 1001001001;
const ll INFL = 1001001001001001001;
const ll MOD = 1000000007;
const ll MOD_ = 998244353;
const V DH = {-1,-1,0,1,1,1,0,-1};
const V DW = {0,1,1,1,0,-1,-1,-1};
struct grid{
    int h, w;
    inline const grid operator+(const grid &p) { return {this->h + p.h, this->w + p.w}; }
    inline const grid operator*(const int &p) { return {this->h * p, this->w * p}; }
    
};
ostream &operator<<(ostream &os, const grid& p) {
    os << p.h << " " << p.w;
    return os;
}
#define rep(i, j, n) for(ll i = (ll)(j); i < (ll)(n); i++)
#define repb(i, j, n) for(ll i = (ll)(n-1); i >= (ll)(j); i--)
#define reps(i, j, n) for(ll i = (ll)(j); i <= (ll)(n); i++)
#define repsb(i, j, n) for(ll i = (ll)(n); i >= (ll)(j); i--)
#define all(a) (a).begin(),(a).end()

template<typename T>
ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i=0; i<(int)v.size(); i++){
        os << v[i] << (i+1 != (int)v.size() ? " " : "");
    }
    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &v){
    for(T &in : v) is >> in;
    return is;
}

template<typename T1, typename T2>
ostream &operator<<(ostream &os, const pair<T1, T2>& p) {
  os << p.first << " " << p.second;
  return os;
}
... ï¼ˆæ®‹ã‚Š 184 è¡Œï¼‰
æŠ˜ã‚ŠãŸãŸã¿
message.txt
8 KB
ï»¿
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <math.h>
#include <iomanip>
#include <fstream>
#include <map>
#include <set>
#include <queue>
#include <list>
#include <iomanip>
#include <numeric>
#include <bitset>
using namespace std;

template<typename T1, typename T2>
class myPair : public std::pair<T1, T2>{
    using std::pair<T1, T2>::pair;
    public:
    inline const myPair<T1, T2> operator+(const myPair<T1, T2> &p) { return {this->first + p.first, this->second + p.second}; }
    inline const myPair<T1, T2> operator-(const myPair<T1, T2> &p) { return {this->first - p.first, this->second - p.second}; }
    template<typename U> inline const  myPair<T1, T2> operator*(const U &p) { return {this->first * p, this->second * p}; }
    template<typename U> inline const  myPair<T1, T2> operator/(const U &p) { return {this->first / p, this->second / p}; }
    inline myPair& operator+=(const myPair<T1, T2> &p) {
        *this = *this + p;
        return *this;
    }
    inline myPair& operator-=(const myPair<T1, T2> &p) {
        *this = *this - p;
        return *this;
    }
    template<typename U> inline myPair& operator*=(const U &x) {
        *this = *this * x;
        return *this;
    }
    template<typename U> inline myPair& operator/=(const U &x) {
        *this = *this / x;
        return *this;
    }
};
#define pair myPair


using ll = long long;
using P = pair<int,int>;
using PL = pair<ll,ll>;
using V = vector<int>;
using VL = vector<ll>;
using VD = vector<double>;
using VC = vector<char>;
using VP = vector<P>;
using VS = vector<string>;
using VV = vector<V>;
using VVL = vector<VL>;
using VVD = vector<VD>;
using VVC = vector<VC>;
using VVP = vector<VP>;
using VVS = vector<VS>;
const int INF  = 1001001001;
const ll INFL = 1001001001001001001;
const ll MOD = 1000000007;
const ll MOD_ = 998244353;
const V DH = {-1,-1,0,1,1,1,0,-1};
const V DW = {0,1,1,1,0,-1,-1,-1};
struct grid{
    int h, w;
    inline const grid operator+(const grid &p) { return {this->h + p.h, this->w + p.w}; }
    inline const grid operator*(const int &p) { return {this->h * p, this->w * p}; }
    
};
ostream &operator<<(ostream &os, const grid& p) {
    os << p.h << " " << p.w;
    return os;
}
#define rep(i, j, n) for(ll i = (ll)(j); i < (ll)(n); i++)
#define repb(i, j, n) for(ll i = (ll)(n-1); i >= (ll)(j); i--)
#define reps(i, j, n) for(ll i = (ll)(j); i <= (ll)(n); i++)
#define repsb(i, j, n) for(ll i = (ll)(n); i >= (ll)(j); i--)
#define all(a) (a).begin(),(a).end()

template<typename T>
ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i=0; i<(int)v.size(); i++){
        os << v[i] << (i+1 != (int)v.size() ? " " : "");
    }
    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &v){
    for(T &in : v) is >> in;
    return is;
}

template<typename T1, typename T2>
ostream &operator<<(ostream &os, const pair<T1, T2>& p) {
  os << p.first << " " << p.second;
  return os;
}

template<typename T1, typename T2>
istream &operator>>(istream &is, pair<T1, T2> &p) {
  is >> p.first >> p.second;
  return is;
}

template<class T>
vector<int> compress(vector<T> &v, int a = 0){
    vector<T> w = v;
    vector<int> ret(v.size());
    sort(w.begin(), w.end());
    w.erase(unique(w.begin(), w.end()), w.end());
    for(int i=0; i<v.size(); i++){
        ret[i] = lower_bound(w.begin(), w.end(), v[i]) - w.begin() + a;
    }
    return ret;
}

void Yes(bool a){
    if(a) cout << "Yes\n";
    else cout << "No\n";
}

template<class T> bool chmin(T& a, T b){
    if(a > b){
        a = b;
        return true;
    }
    return false;
}

template<class T> bool chmax(T& a, T b){
    if(a < b){
        a = b;
        return true;
    }
    return false;
}

template<class T> T power(T x, ll n) {
    T ret = 1;
    while (n > 0) {
        if (n & 1) ret = ret * x/* % MOD*/;
        x = x * x/* % MOD*/;
        n >>= 1;
    }
    return ret;
}

ll round_up(ll a, ll b){
    return (a + b - 1) / b;
}

ll gcd(ll a, ll b){
    if(a % b == 0){
        return(b);
    }else{
        return(gcd(b, a % b));
    }
}

ll lcm(ll a, ll b){
    return a / gcd(a, b) * b ;
}

int rev(VV &table, bool turn, grid pos){
    int res = 0;
    if(table[pos.h][pos.w] != -1) return 0;
    rep(i,0,8){
        grid vec = {DH[i], DW[i]};
        int cnt = 0;
        reps(j,1,8){
            grid ne = pos + (vec * (int)j);
            if(ne.h < 0 || ne.h >= 8 || ne.w < 0 || ne.w >= 8){
                cnt = 0;
                break;
            }
            if(table[ne.h][ne.w] == -1){
                cnt = 0;
                break;
            }
            if(!turn ^ table[ne.h][ne.w]){
                break;
            }
            else cnt++;
            
        }
        res += cnt;
    }
    return res;
}

void rev_execute(VV &table, bool turn, grid pos){
    vector<grid> res;
    rep(i,0,8){
        grid vec = {DH[i], DW[i]};
        vector<grid> rev_pos;
        reps(j,1,8){
            grid ne = pos + (vec * (int)j);
            if(ne.h < 0 || ne.h >= 8 || ne.w < 0 || ne.w >= 8){
                rev_pos.clear();
                break;
            }
            if(table[ne.h][ne.w] == -1){
                rev_pos.clear();
                break;
            }
            if(!turn ^ table[ne.h][ne.w]){
                break;
            }
            else rev_pos.push_back(ne);
        }
        res.insert(res.end(), rev_pos.begin(), rev_pos.end());
    }
    table[pos.h][pos.w] = turn;
    for(auto gr : res) table[gr.h][gr.w] = !table[gr.h][gr.w];
}


void print(VV &table){
    rep(i,0,8){
        rep(j,0,8){
            if(table[i][j] == -1) cout << ".";
            if(table[i][j] == 1) cout << "o";
            if(table[i][j] == 0) cout << "x";
        }
        cout << endl;
    }
}

int main(void){
	
    //input

    VS T(8);
    cin >> T;
    VV table(8, V(8));
    rep(i,0,8){
        rep(j,0,8){
            if(T[i][j] == 'o'){
                table[i][j] = 1;
            }
            else if(T[i][j] == 'x'){
                table[i][j] = 0;
            }
            else table[i][j] = -1;
        }
    }

    //calculate

    bool turn = true;
    int pass_cnt = 0;
    while(pass_cnt < 2){
        vector<grid> can_rev;
        int max = 1; 
        rep(i,0,8){
            rep(j,0,8){
                grid pos = {(int)i, (int)j};
                int pre_rev = rev(table, turn, pos);
                if(max == pre_rev){
                    can_rev.push_back(pos);
                }
                if(max < pre_rev){
                    can_rev = {pos};
                    max =  pre_rev;
                }
            }
        }
        if(!can_rev.empty()){
            pass_cnt = 0;
            if(turn) rev_execute(table, turn, can_rev.front());
            else rev_execute(table, turn, can_rev.back());
        }
        else pass_cnt++;
        turn = !turn; 
    }
    print(table);

    


}
